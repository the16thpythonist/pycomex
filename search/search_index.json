{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pycomex Documentation","text":"<p>Welcome to the pycomex documentation site powered by Material for MkDocs.</p> <p>This site is under construction.</p>"},{"location":"advanced_hooks/","title":"Plugin Hooks","text":"<p>This page aims to provide a (non-exhaustive) list of the available hooks in the pycomex library. Each hook is described with its name, a brief description, and the parameters it accepts.</p>"},{"location":"advanced_hooks/#plugin_registered","title":"\ud83e\ude9d <code>plugin_registered</code>","text":"<p>This hook is executed right after a plugin is registerd. The hook receives the name of the plugin that was registered as well as the plugin object itself. This hook can for example be used to hot-swap or replace certain plugins with newer or alternative versions.</p> Parameter Description <code>name</code> The name of the plugin that was registered <code>plugin</code> The <code>Plugin</code> object instance that was registered <code>config</code> The <code>Config</code> instance that is used by the pycomex library <p>Returns: None</p>"},{"location":"advanced_hooks/#plugin_registered__plugin_name","title":"\ud83e\ude9d <code>plugin_registered__{plugin_name}</code>","text":"<p>This hook is executed right after a plugin is registered. The name of the hook is dynamically derived from the name of the actual plugin. Therefore, only the plugin itself will likely be able to know the name of this hook and be able to register a function to it.</p> Parameter Description <code>plugin</code> The <code>Plugin</code> object instance that was registered <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#experiment-hooks","title":"<code>Experiment</code> Hooks","text":""},{"location":"advanced_hooks/#before_experiment_parameters","title":"\ud83e\ude9d <code>before_experiment_parameters</code>","text":"<p>This hook is executed within the lifetime of an <code>Experiment</code> instance after its construction - right before the experiment parameters are processed. </p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself"},{"location":"advanced_hooks/#experiment_constructed","title":"\ud83e\ude9d <code>experiment_constructed</code>","text":"<p>This hook is executed at the end of the <code>Experiment</code> constructor. It can be used to perform additional setup steps once the experiment object exists.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance that was created <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#after_experiment_initialize","title":"\ud83e\ude9d <code>after_experiment_initialize</code>","text":"<p>Executed after the <code>Experiment.initialize</code> method completed. At this point the archive folder has been created and the experiment is ready to run.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#after_experiment_finalize","title":"\ud83e\ude9d <code>after_experiment_finalize</code>","text":"<p>Executed after the <code>Experiment.finalize</code> method completed. This allows for additional cleanup or post-processing once the experiment is finished.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#experiment_commit_fig","title":"\ud83e\ude9d <code>experiment_commit_fig</code>","text":"<p>Called at the end of <code>Experiment.commit_fig</code> after the figure has been saved to the archive folder.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>name</code> The name of the saved figure file <code>figure</code> The <code>matplotlib</code> figure instance <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#experiment_commit_json","title":"\ud83e\ude9d <code>experiment_commit_json</code>","text":"<p>Called at the end of <code>Experiment.commit_json</code> once the JSON file has been written.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>name</code> The name of the saved JSON file <code>data</code> The original data structure that was saved <code>content</code> The string representation that was written to the file <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#experiment_commit_raw","title":"\ud83e\ude9d <code>experiment_commit_raw</code>","text":"<p>Called at the end of <code>Experiment.commit_raw</code> after the text file has been created.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>name</code> The name of the saved file <code>content</code> The text content that was written <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#experiment_track","title":"\ud83e\ude9d <code>experiment_track</code>","text":"<p>Called at the end of <code>Experiment.track</code>. It receives the tracked name and value so that the tracking information can be forwarded to external services.</p> Parameter Description <code>experiment</code> The <code>Experiment</code> instance itself <code>name</code> Name under which the value was tracked <code>value</code> The tracked value or figure <code>config</code> The <code>Config</code> instance that is used by the pycomex library"},{"location":"advanced_hooks/#config-hooks","title":"<code>Config</code> Hooks","text":""},{"location":"advanced_hooks/#after_plugins_loaded","title":"\ud83e\ude9d <code>after_plugins_loaded</code>","text":"<p>This hook is executed right after the plugins are loaded and before the configuration is finalized. This is one of the earliest possible entry points for any plugin and could for example be used for some early initialization tasks.</p> Parameter Description <code>config</code> The <code>Config</code> instance itself <code>plugins</code> A dictionary where the string keys are the plugin names and the values are the corresponding <code>Plugin</code> object instances"},{"location":"advanced_plugins/","title":"Writing Plugins","text":"<p>The pycomex library is designed to be extensible through a plugin system. Plugins can be used to add new functionality, modify existing behavior, or integrate with external systems. This document provides guidelines for writing and integrating plugins into the pycomex library.</p>"},{"location":"advanced_plugins/#the-hook-system","title":"The Hook System","text":"<p>Plugins are implemented using a hook system. During various stages of the experiment lifetime of the computational experiment, the pycomex library will call specific \"hook\" functions. These hook functions are primarily placeholders associated with a known and unique string identifier. Each new plugin has the option to register custom function implementations to these hooks such that this custom code will be executed at various stages of the experiment lifecycle.</p> <p>Depending on the specific hook, these functions may receive various arguments or may be required to return specific values. These arguments and return values can then usually be used to modify the behavior of the pycomex library itself to achieve the intended functionality of the plugin.</p> <p>As an example, one can imagine a very simple plugin that prints a simple \"Hello World\" message before the start of each experiment. For such a use case, it would make most sense to register a custom function to the <code>before_experiment</code> hook. This hook is called right before the experiment starts.</p> <p>To implement an intended plugin functionality, one necessary step is therefore to familiarize oneself with the available hooks that are provided by the pycomex library.</p>"},{"location":"advanced_plugins/#plugin-discovery","title":"Plugin Discovery","text":"<p>The discovery of plugins is done as one of the very first steps of the pycomex library. The discovery is basically split into an internal and an external discovery step.</p> <p>Internal Plugins. These are the plugins which are shipped together with the pycomex library itself. These plugins are the default plugins that come with the library and are located in the <code>pycomex/plugins</code> directory. Each folder in this plugins directory is assumed to be its own plugin.</p> <p>External Plugins. These are the plugins which can be installed by the user. During the plugin discovery stage, the library will assume every Python package that is installed in the current environment starting with the string <code>pycomex_</code> to be its own plugin.</p>"},{"location":"advanced_plugins/#creating-a-plugin","title":"Creating a Plugin","text":"<p>Based on the previous section, the primary method of creating a new plugin is to create a new Python package whose name starts with the prefix <code>pycomex_</code>. This package can then contain any number of Python modules, which can implement the intended functionality of the plugin, but it must contain a <code>main.py</code> module which acts as the entry point for the plugin managment system.</p> <p>The <code>main.py</code> module should implement a subclass of the <code>pycomex.plugins.Plugin</code> class. This subclass is where the plugin's functionality is defined, and it should register the necessary hooks that the plugin will use. This class may have any name, so long as it inherits from the <code>pycomex.plugins.Plugin</code> class.</p> <p>Example. As an example, we'll consider a simple plugin that adds additional messages at the beginning and end of each experiment. The plugin will be called <code>pycomex_hello_world</code>.</p> pycomex_hello_world/main.py<pre><code>from pycomex.plugins import Plugin, hook\n\nclass HelloWorldPlugin(Plugin):\n\n    @hook('before_experiment', priority=0)\n    def before_experiment(self, *args, **kwargs):\n        print('Hello World! The experiment is about to start.')\n\n    @hook('after_experiment', priority=0)\n    def after_experiment(self, *args, **kwargs):\n        print('Goodbye World! The experiment has finished.')\n</code></pre> <p>To complete the plugin, you'll need to ensure that the package is installed in your Python environment. This can be done by creating an appropriate <code>pyproject.toml</code> or <code>setup.py</code> file.</p> <p>Plugin Initialization</p> <p>Do not use the default python <code>__init__</code> constructor of your custom plugin class, as the actual plugin object instance will be automatically created by the plugin system internally. Instead use the <code>init</code> hook to perform any necessary setup operations which would usually be done in the constructor. This hook will be called right after the plugin object instance is created. </p> <p>Summary. To summarize a plugin can be created by the following steps:</p> <ol> <li>Create a new Python package with the name starting with <code>pycomex_</code>.</li> <li>Create a <code>main.py</code> module inside this package.</li> <li>Implement a subclass that inherits from the <code>pycomex.plugins.Plugin</code> class inside the <code>main.py</code> module.</li> <li>Register the necessary hooks inside of this subclass.</li> </ol>"},{"location":"basics_hooks/","title":"Basic Hooks in PyComex","text":"<p>Hooks in PyComex are user-defined functions that execute at specific points during your experiment via <code>e.apply_hook()</code>. They provide a flexible way to inject custom functionality without modifying core experiment logic.</p> <p>Key characteristics: - Experiment-specific with decorator-based registration (<code>@experiment.hook()</code>) - Executed on demand when called via <code>e.apply_hook()</code> - Receive the experiment instance and additional parameters</p>"},{"location":"basics_hooks/#hook-structure","title":"Hook Structure","text":"<pre><code>from pycomex.functional.experiment import Experiment\nfrom pycomex.utils import file_namespace, folder_path\n\n# Define experiment parameters\nDATASET = \"training_data.csv\"\n\n# Create experiment instance\nexperiment = Experiment(\n    base_path=folder_path(__file__),\n    namespace=file_namespace(__file__),\n    glob=globals(),\n)\n\n# Define hooks BEFORE the main experiment function\n@experiment.hook(\"load_data\")\ndef load_dataset(e: Experiment, dataset_name: str):\n    e.log(f\"Loading dataset: {dataset_name}\")\n    return f\"data_from_{dataset_name}\"\n\n@experiment.hook(\"preprocess\")\ndef clean_data(e: Experiment, data: str):\n    e.log(f\"Preprocessing: {data}\")\n    return data.upper()\n\n# Main experiment function\n@experiment\ndef main_experiment(e: Experiment):\n    e.log(\"Starting experiment\")\n    raw_data = e.apply_hook(\"load_data\", dataset_name=e.DATASET)\n    processed_data = e.apply_hook(\"preprocess\", data=raw_data)\n    e[\"result\"] = processed_data\n\nexperiment.run_if_main()\n</code></pre>"},{"location":"basics_hooks/#hook-registration-options","title":"Hook Registration Options","text":"<pre><code>@experiment.hook(\"hook_name\", replace=True, default=True)\ndef my_hook(e: Experiment, **kwargs):\n    pass\n</code></pre> <ul> <li><code>replace=True</code> (default): Replace existing hooks with same name</li> <li><code>replace=False</code>: Append to existing hooks (executed in order)</li> <li><code>default=True</code> (default): Only register if no other hooks exist</li> <li><code>default=False</code>: Always register this hook</li> </ul>"},{"location":"basics_hooks/#multiple-hooks-example","title":"Multiple Hooks Example","text":"<pre><code># Register multiple hooks for the same point\n@experiment.hook(\"validate\", replace=False)\ndef check_format(e: Experiment, data):\n    assert isinstance(data, str), \"Data must be string\"\n    return data\n\n@experiment.hook(\"validate\", replace=False)\ndef check_length(e: Experiment, data):\n    assert len(data) &gt; 0, \"Data cannot be empty\"\n    return data\n\n@experiment\ndef main_experiment(e: Experiment):\n    data = \"sample_data\"\n    validated_data = e.apply_hook(\"validate\", data=data)  # Both hooks execute\n</code></pre>"},{"location":"basics_hooks/#hook-documentation","title":"Hook Documentation","text":"<p>PyComex automatically parses hook documentation from special comment syntax:</p> <pre><code>@experiment\ndef documented_experiment(e: Experiment):\n    # :hook preprocess_data:\n    #       Preprocesses input data by applying normalization and cleaning.\n    processed_data = e.apply_hook(\"preprocess_data\", raw_data=\"input_data\")\n</code></pre> <p>Descriptions are added to experiment metadata and viewable in the experiment archive.</p>"},{"location":"basics_hooks/#experiment-inheritance-with-hooks","title":"Experiment Inheritance with Hooks","text":"<p>Child experiments can override parent hooks:</p> <pre><code># Parent experiment: base_experiment.py\n@experiment.hook(\"process_data\")\ndef basic_processing(e: Experiment, data):\n    return data.lower()\n\n# Child experiment: advanced_experiment.py\nexperiment = Experiment.extend(\n    experiment_path=\"base_experiment.py\",\n    base_path=folder_path(__file__),\n    namespace=file_namespace(__file__),\n    glob=globals(),\n)\n\n@experiment.hook(\"process_data\")  # Overrides parent hook\ndef advanced_processing(e: Experiment, data):\n    return data.upper() + \"!!!\"\n</code></pre>"},{"location":"basics_hooks/#best-practices","title":"Best Practices","text":""},{"location":"basics_hooks/#when-to-use-hooks","title":"When to Use Hooks","text":"<p>Use hooks for experiment steps that: 1. Have clear interfaces with well-defined parameters and return values 2. Are potentially replaceable (different implementations) 3. Separate concerns (data loading, training, evaluation, etc.) 4. Are reusable across multiple experiments</p>"},{"location":"basics_hooks/#common-use-cases","title":"Common Use Cases","text":"<p>Data Management: Loading, preprocessing, validation, splitting Model Operations: Creation, training, evaluation, persistence Visualization: Plot generation, report creation, result comparison Flow Control: Setup/teardown, checkpointing, error handling</p>"},{"location":"basics_hooks/#design-guidelines","title":"Design Guidelines","text":"<ol> <li>Keep hooks focused - Single responsibility per hook</li> <li>Use descriptive names - Clear purpose (<code>validate_input_data</code> not <code>step1</code>)</li> <li>Handle parameters gracefully - Provide defaults and validate inputs</li> <li>Document interfaces - Specify expected parameters and return values</li> <li>Return appropriately - Return processed data for transformations</li> </ol> <pre><code>@experiment.hook(\"normalize_features\")\ndef normalize_data(e: Experiment, data: np.ndarray, method: str = \"standard\"):\n    \"\"\"Normalize feature data using specified method.\"\"\"\n    if method not in [\"standard\", \"minmax\", \"robust\"]:\n        e.log(f\"Unknown method '{method}', using 'standard'\")\n        method = \"standard\"\n    # Implementation here\n    return normalized_data\n</code></pre>"},{"location":"basics_hooks/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":"<ul> <li>Don't make experiments depend on hooks - Provide defaults for missing hooks</li> <li>Don't use hooks for simple configuration - Use experiment parameters instead</li> <li>Don't make hooks interdependent - Each hook should be independently functional</li> </ul> <pre><code># Good: Provide defaults\ndata = e.apply_hook(\"load_data\", default=[1, 2, 3])\n\n# Good: Use parameters for config\nLEARNING_RATE = 0.01  # Not a hook\n</code></pre>"},{"location":"basics_hooks/#next-steps","title":"Next Steps","text":"<ul> <li>For more advanced hook usage and system-level plugin hooks, see Advanced Hooks</li> <li>For plugin development using hooks, see Advanced Plugins</li> <li>For experiment inheritance patterns, see the inheritance example</li> </ul>"},{"location":"introduction/","title":"PyComex \u22c5 Computational Experiments","text":"<p>The <code>pycomex</code> package is a microframework for Python that simplifies the implementation, execution and management of computational experiments. The framework defines a natural way of implementing computational experiments in the form of individual Python scripts that automatically manage their own results, metadata, and artifacts.</p> <p>\ud83d\udca1 Note. Speaking in terms of other existing technologies, pycomex aims to be an opinionated alternative to Hydra Configs and a local version of Weights &amp; Biases, but with a focus on flexibility and extensibility.</p>"},{"location":"introduction/#installation","title":"Installation","text":""},{"location":"introduction/#package-installation","title":"Package Installation","text":"<p>Install the stable version from PyPI:</p> <pre><code>pip install pycomex\n</code></pre>"},{"location":"introduction/#development-installation","title":"Development Installation","text":"<p>For the latest development version, clone the repository:</p> <pre><code>git clone https://github.com/the16thpythonist/pycomex.git\ncd pycomex\npip install -e .\n</code></pre> <p>Or using uv (recommended):</p> <pre><code>git clone https://github.com/the16thpythonist/pycomex.git\ncd pycomex\nuv pip install -e .\n</code></pre>"},{"location":"introduction/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Core dependencies are automatically installed with the package</li> </ul>"},{"location":"introduction/#quickstart","title":"Quickstart","text":"<p>PyComex turns your computational experiments into structured, reproducible, and automatically archived processes. Here's how to get started:</p>"},{"location":"introduction/#basic-experiment-structure","title":"Basic Experiment Structure","text":"<p>Each experiment is a Python module with uppercase variables as parameters and a main function decorated with <code>@Experiment()</code>:</p> <pre><code># my_first_experiment.py\n\"\"\"\nThis docstring describes what the experiment does and is saved as metadata.\n\"\"\"\n\nfrom pycomex.functional.experiment import Experiment\nfrom pycomex.utils import file_namespace, folder_path\n\n# Experiment parameters (uppercase variables are auto-detected)\nLEARNING_RATE: float = 0.001\nEPOCHS: int = 100\nMODEL_NAME: str = \"simple_nn\"\n\n# Enable debug mode to reuse the same archive folder\n__DEBUG__ = True\n\n@Experiment(\n    base_path=folder_path(__file__),  # Results stored relative to this file\n    namespace=file_namespace(__file__),  # Creates folder based on filename\n    glob=globals(),  # Gives access to parameters\n)\ndef experiment(e: Experiment) -&gt; None:\n    e.log(\"Starting training experiment...\")\n\n    # Store metadata (creates nested structure in JSON)\n    e[\"config/learning_rate\"] = LEARNING_RATE\n    e[\"config/epochs\"] = EPOCHS\n    e[\"model/name\"] = MODEL_NAME\n\n    # Simulate training loop\n    for epoch in range(EPOCHS):\n        loss = 1.0 / (epoch + 1)  # Dummy loss that decreases\n\n        # Track metrics over time\n        e.track(\"metrics/loss\", loss)\n        e.track(\"metrics/epoch\", epoch)\n\n        if epoch % 20 == 0:\n            e.log(f\"Epoch {epoch}: Loss = {loss:.4f}\")\n\n    # Save final results\n    e[\"results/final_loss\"] = loss\n    e.commit_raw(\"training_log.txt\", f\"Final loss: {loss}\")\n\n# Run the experiment when script is executed directly\nexperiment.run_if_main()\n</code></pre>"},{"location":"introduction/#running-your-experiment","title":"Running Your Experiment","text":"<p>Execute your experiment by running the Python file:</p> <pre><code>python my_first_experiment.py\n</code></pre>"},{"location":"introduction/#generated-archive-structure","title":"Generated Archive Structure","text":"<p>PyComex automatically creates this organized structure:</p> <pre><code>my_first_experiment/\n\u2514\u2500\u2500 debug/  # or timestamped folder if __DEBUG__ = False\n    \u251c\u2500\u2500 experiment_meta.json    # Experiment metadata\n    \u251c\u2500\u2500 experiment_data.json    # All tracked data and metrics\n    \u251c\u2500\u2500 experiment_out.log      # Complete execution log\n    \u251c\u2500\u2500 experiment_code.py      # Snapshot of your experiment code\n    \u251c\u2500\u2500 analysis.py            # Ready-to-run analysis code\n    \u251c\u2500\u2500 training_log.txt       # Your committed artifacts\n    \u2514\u2500\u2500 tracked/               # Auto-generated visualizations\n        \u2514\u2500\u2500 metrics_loss.png   # Automatic plot of tracked metrics\n</code></pre>"},{"location":"introduction/#command-line-interface","title":"Command Line Interface","text":"<p>PyComex provides powerful CLI tools:</p> <pre><code># List recent experiments\npycomex archive list\n\n# View basic information about experiment archive\npycomex archive info\n\n# Create new experiment from template\npycomex template experiment my_new_experiment.py\n</code></pre>"},{"location":"introduction/#parameter-overrides","title":"Parameter Overrides","text":"<p>Override parameters from the command line without modifying code:</p> <pre><code>python my_first_experiment.py --LEARNING_RATE 0.01 --EPOCHS 50\n</code></pre>"},{"location":"introduction/#key-features-in-action","title":"Key Features in Action","text":"<ol> <li>Automatic Archiving: Every run creates a complete record</li> <li>Metadata Tracking: Store structured data with <code>e[\"path/key\"] = value</code></li> <li>Time Series Tracking: Use <code>e.track()</code> for metrics that change over time</li> <li>Auto Visualization: PyComex automatically plots tracked numerical data</li> <li>Reloadability: Load any experiment back into memory for analysis</li> <li>Debug Mode: Use <code>__DEBUG__ = True</code> for iterative development</li> </ol>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Explore parameter inheritance and experiment composition</li> <li>Learn about hooks for custom behavior injection</li> <li>Discover advanced archiving and analysis features</li> <li>Check out plugin integrations (Weights &amp; Biases, notifications)</li> </ul> <p>This quickstart covers the essentials. PyComex's real power emerges as your experimental needs grow more complex\u2014it scales from simple scripts to sophisticated experimental pipelines while maintaining the same clean, structured approach.</p>"},{"location":"philosophy/","title":"Philosophy","text":""},{"location":"philosophy/#introduction","title":"Introduction","text":"<p>PyComex was born from the recognition that computational experiments, while fundamental to scientific computing and data science, are often conducted in an ad-hoc manner that leads to reproducibility issues, lost results, and inefficient workflows. The framework embodies a philosophy of structured experimentation where every computational experiment is treated as a first-class citizen with its own identity, metadata, and lifecycle.</p> <p>At its core, PyComex believes that experiments should be self-documenting, reproducible, and easily analyzable. Rather than scattering experiment scripts across directories with inconsistent naming and organization, PyComex provides a systematic approach that captures not just the code, but the complete experimental context including parameters, outputs, intermediate results, and analysis artifacts.</p>"},{"location":"philosophy/#solving-common-experimental-challenges","title":"Solving Common Experimental Challenges","text":""},{"location":"philosophy/#asset-management","title":"Asset Management","text":"<p>One of the most pervasive problems in computational experimentation is the chaos of asset management. Researchers and data scientists often find themselves with directories full of scattered files: input data here, output plots there, model checkpoints somewhere else, and configuration files everywhere. This fragmentation makes it nearly impossible to understand what belongs to which experiment, leading to lost work and irreproducible results.</p> <p>PyComex solves this through automatic experiment archiving. Every experiment execution creates a self-contained directory structure with a timestamp and namespace, ensuring that all assets\u2014input files, generated outputs, plots, logs, and metadata\u2014are co-located and properly organized. The framework automatically captures the experiment's state, including the exact code version, parameter values, and execution environment, creating a complete experimental record that can be revisited months or years later.</p> <p>This systematic organization means that finding the results from \"that experiment I ran last Tuesday\" becomes trivial rather than a archaeological expedition through your file system.</p>"},{"location":"philosophy/#experiment-deviations-and-evolution","title":"Experiment Deviations and Evolution","text":"<p>Real experimental work rarely follows a linear path. You start with one set of parameters, realize you need to test a variation, want to override a single value for a quick test, or need to inject custom behavior through hooks. Traditional approaches often lead to copying and modifying entire scripts, creating a branching nightmare of slightly different versions that become impossible to track.</p> <p>PyComex embraces this reality through inheritance and hook systems. The framework allows experiments to inherit from base configurations while overriding specific parameters, creating clear lineages of experimental evolution. Hook systems enable you to inject custom behavior\u2014like specialized logging, notifications, or data preprocessing\u2014without modifying the core experiment logic.</p> <p>This approach means you can maintain a clean experimental history while supporting the natural branching and variation that real research requires. Every experiment knows its lineage and deviations, making it easy to understand how results evolved over time.</p>"},{"location":"philosophy/#quantity-tracking-and-data-persistence","title":"Quantity Tracking and Data Persistence","text":"<p>Computational experiments generate vast amounts of intermediate data: metrics during training, intermediate results, diagnostic information, and final outputs. Managing this information typically involves manual bookkeeping with inconsistent formats, making it difficult to compare results across experiments or perform meta-analyses.</p> <p>PyComex provides structured quantity tracking through the <code>.track()</code> method that makes storing evolving parameters and artifacts effortless. The framework automatically compiles tracked data over time, creating comprehensive records of how values change throughout an experiment's execution. This goes far beyond simple logging\u2014PyComex automatically generates visualizations of your tracked data, creating plots for numerical values and videos from sequences of tracked images.</p> <p>The system intelligently handles different data types, automatically creating the most appropriate visualization: line plots for scalar metrics over time, animated videos for image sequences, and structured compilations for complex artifacts. This automatic compilation and visualization means that understanding your experiment's behavior becomes immediate and intuitive, without requiring manual post-processing or custom visualization code.</p>"},{"location":"philosophy/#post-experiment-analysis-and-reloadability","title":"Post-Experiment Analysis and Reloadability","text":"<p>Perhaps the most overlooked aspect of experimental workflows is what happens after an experiment completes. Traditional approaches often leave you with raw output files that require custom parsing and loading code, making it difficult to perform retrospective analysis or build on previous results.</p> <p>PyComex addresses this through experiment reloadability. Every archived experiment can be loaded back into memory with full access to its original parameters, tracked data, and generated artifacts. The framework provides a consistent API for exploring experimental results, whether you're analyzing a single experiment or comparing across dozens of experimental runs.</p> <p>This capability transforms post-experiment analysis from a tedious manual process into a streamlined investigation. You can easily load experiments, compare their results, generate visualizations, and perform meta-analyses using the same tools and interfaces, regardless of when the experiments were originally run.</p> <p>The framework also automatically generates analysis boilerplate code for each experiment, providing a starting point for deeper investigation and ensuring that the analysis workflow is as systematic as the experimental execution itself.</p>"}]}