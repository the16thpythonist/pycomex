"""
Command implementations for running and reproducing experiments.
"""

import json
import os
import subprocess
import sys
import tempfile
import zipfile

import rich_click as click
from uv import find_uv_bin

from pycomex.functional.experiment import Experiment
from pycomex.utils import dynamic_import, get_environment_info
from pycomex.cli.display import RichEnvironmentComparison


class RunCommandsMixin:
    """
    Mixin class providing run-related CLI commands.

    This mixin provides commands for:
    - inspect: Inspecting a previously terminated experiment
    - reproduce: Reproducing an experiment from an archive
    - run: Running an experiment module or config file
    """

    @click.command(
        "inspect", short_help="inspect an experiment that was previously terminated."
    )
    @click.argument("experiment_path", type=click.Path(exists=True))
    @click.pass_obj
    def inspect_command(self, experiment_path: str) -> None:
        """
        This command will pass
        """
        experiment_path = os.path.abspath(experiment_path)
        click.secho(f"inspecting experiment @ {experiment_path}")

        # TODO: Implement some pretty printing that shows the metadata etc.

    @click.command(
        "reproduce",
        short_help="reproduce an experiment that was previously terminated in reproducible mode.",
        context_settings={"ignore_unknown_options": True},
    )
    @click.option(
        "--env-only",
        is_flag=True,
        help="Only create the virtual environment and install dependencies.",
    )
    @click.argument("experiment_path", type=click.Path(exists=True))
    @click.argument("experiment_args", type=click.UNPROCESSED, nargs=-1)
    @click.pass_obj
    def reproduce_command(
        self, env_only: bool, experiment_path: str, experiment_args: str
    ) -> None:
        """
        [bright]This command will attempt to execute an experiment that was previously exported in "reproducible" mode. The
        [bold cyan]EXPERIMENT_PATH[/] may either point to an experiment archive folder or a ZIP file containing an
        experiment archive folder.

        [bright]To reproduce the experiment, the command will first reconstruct a virtual environment with the same
        conditions as the original experiment was run in. By default, the experiment will then be executed. To
        only create the virtual environment and install the dependencies, the --env-only flag can be used.
        """
        # processing the experiment arguments
        experiment_options = {}
        for arg in experiment_args:
            if arg.startswith("--"):
                key_value = arg[2:].split("=", 1)
                if len(key_value) == 2:
                    key, value = key_value
                    experiment_options[key] = value

        experiment_path = os.path.abspath(experiment_path)
        click.secho(
            "attempting to reproduce experiment @ "
            + click.style(experiment_path, fg="cyan")
        )
        # The basis for the reproduction of an experiment is the archive folder that is generated by a terminated previous
        # run of an experiment. There are two ways of providing this archive folder to this command: Either directly as
        # a folder or as an archive path which first needs to be extracted into a folder.
        if os.path.isfile(experiment_path):
            if zipfile.is_zipfile(experiment_path):
                archive_path = experiment_path
                with zipfile.ZipFile(archive_path, "r") as zip_ref:
                    temp_dir = tempfile.mkdtemp(dir=os.path.dirname(experiment_path))
                    zip_ref.extractall(temp_dir)
                    experiment_path = temp_dir

            else:
                click.secho("the provided file path is not a valid archive!", fg="red")
                return

        if not os.path.isdir(experiment_path):
            click.secho("the provided path is not a valid directory!", fg="red")
            return

        # Now that we are sure that we have a valid folder path, we need to check if the given folder
        # actually contains a valid experiment archive.
        if not Experiment.is_archive(experiment_path):
            click.secho(
                "The given folder path is not a valid experiment archive!", fg="red"
            )
            return

        # If we are now sure that the experiment is in fact a valid experiment archive, we can then load the
        # metadata from that experiment. This metadata can then be used to check if the experiment was stored
        # in reproducible mode. If it wasn't we can also terminate the command.
        metadata: dict = Experiment.load_metadata(experiment_path)
        reproducible = (
            metadata["parameters"].get("__REPRODUCIBLE__", {}).get("value", False)
        )
        if not reproducible:
            click.secho(
                "The experiment was not stored in reproducible mode!", fg="red"
            )
            return

        uv = os.fsdecode(find_uv_bin())
        # At this point we can now actually be sure that the given experiment path is valid and that the
        # experiment was stored in valid mode. We can now proceed to actually go through the steps for the
        # reproduction of the experiment.

        # Load dependencies first to extract Python version
        dependencies_path = os.path.join(
            experiment_path, Experiment.DEPENDENCIES_FILE_NAME
        )
        with open(dependencies_path) as file:
            content: str = file.read()
            dependencies: dict = json.loads(content)

        # Extract Python version from dependencies
        python_version = "3.10"  # Fallback default for legacy experiments
        if "__python__" in dependencies:
            version_info = dependencies["__python__"]["version_info"]
            python_version = f"{version_info['major']}.{version_info['minor']}"
            click.secho(
                f"... detected Python {python_version} from original experiment",
                fg="bright_black"
            )
        else:
            click.secho(
                f"... no Python version info found, using default {python_version}",
                fg="yellow"
            )

        # Display environment comparison if environment info is available
        if "__environment__" in dependencies:
            click.secho("\n")
            original_env = dependencies["__environment__"]
            current_env = get_environment_info()

            env_comparison = RichEnvironmentComparison(original_env, current_env)
            self.cons.print(env_comparison)
            click.secho("\n")
        else:
            click.secho(
                "... no environment info found in experiment (legacy experiment)",
                fg="bright_black"
            )

        # Create virtual environment with the detected Python version
        venv_path = os.path.join(experiment_path, ".venv")
        if not os.path.exists(venv_path):
            click.secho("... creating virtual environment", fg="bright_black")
            subprocess.run([uv, "venv", "--python", python_version, "--seed", venv_path])

        env = os.environ.copy()
        env["VIRTUAL_ENV"] = venv_path

        click.secho("... installing dependencies", fg="bright_black")
        with tempfile.NamedTemporaryFile("w", delete=True) as file:
            for dep_info in dependencies.values():
                if not dep_info["editable"]:
                    file.write(f'{dep_info["name"]}=={dep_info["version"]}\n')

            file.flush()
            subprocess.run([uv, "pip", "install", "--requirement", file.name], env=env)

        click.secho("... installing sources", fg="bright_black")
        sources_path = os.path.join(experiment_path, ".sources")
        for file_name in os.listdir(sources_path):
            source_path = os.path.join(sources_path, file_name)
            subprocess.run([uv, "pip", "install", "--no-deps", source_path], env=env)

        if env_only:
            click.secho(
                "environment setup complete. skipping experiment execution...",
                fg="green",
            )

        # ~ running the experiment
        click.secho("... collecting parameters", fg="bright_black")
        experiment_parameters = {
            name: info["value"]
            for name, info in metadata["parameters"].items()
            # The boolean usable flag indicates whether ot not a parameter was actually a simple-enough type to
            # be properly json serialized into the metadata file or not. In case it wasn't, we can't use it here.
            if "usable" in info and info["usable"]
        }
        experiment_parameters.update({"__DEBUG__": False, "__REPRODUCIBLE__": False})
        experiment_parameters.update(experiment_options)
        kwargs = [f"--{name}={value}" for name, value in experiment_parameters.items()]

        # Finally we can use uv again to execute the copy of the experiment code that has been stored in the
        # experiment archive as well.
        click.secho("... running experiment", fg="bright_black")
        code_path = os.path.join(experiment_path, Experiment.CODE_FILE_NAME)
        subprocess.run([uv, "run", "--no-project", code_path, *kwargs], env=env)

    @click.command(
        "run",
        short_help="Run an experiment module or config file.",
        context_settings=dict(ignore_unknown_options=True),
    )
    @click.argument("path", type=click.Path(exists=True, resolve_path=True))
    @click.argument("experiment_parameters", nargs=-1)
    @click.pass_obj
    def run_command(
        self,
        path: str,
        experiment_parameters: tuple,
    ) -> None:
        """
        Executes the experiment module or config file at the given PATH.
        """
        click.secho(f"Running experiment module @ {path}")
        extension = os.path.basename(path).split(".")[-1]

        # ~ create experiment
        experiment: Experiment | None = None

        # In case of a yml file, we assume that this is a config file which extends upon
        # an existing experiment module.
        if extension in ["yml", "yaml"]:
            experiment = Experiment.from_config(
                config_path=path,
            )

        # In the case of the python file, we assume that this directly represents a python
        # experiment module.
        elif extension in ["py"]:
            module = dynamic_import(path)
            if hasattr(module, "__experiment__"):
                experiment = module.__experiment__

            else:
                click.secho(
                    "The given python file does not contain a valid experiment module!",
                    fg="red",
                )
                return

        # Now we parse out all of the parameters that were passed as additional options to
        # the "run" command.
        experiment.arg_parser.parse(experiment_parameters)

        # 15.10.2025 - After parsing command line arguments, we need to sync special parameters
        # like __DEBUG__ and __CACHING__ which have side effects beyond simple value storage.
        # Without this call, self.debug won't be updated from self.parameters['__DEBUG__'],
        # causing the experiment to run in the wrong mode even though the parameter value is correct.
        # This matches the pattern used in experiment.run_if_main() which correctly syncs these parameters.
        experiment.update_parameters_special()

        click.echo("Starting the experiment...")
        experiment.run()
